#!/usr/bin/env ruby

def usage(msg = nil)
  puts "ERROR: #{msg}" if msg
  puts <<USAGE
USAGE:
  mb host|method|path [VAL]      - Set or display current config item
  mb accept [ACC1] [ACC2] [etc]  - Set or display accept types
  mb payload [-]                 - Set (from STDIN) or display payload config
  mb config                      - Display current config
  mb [get|delete] [PATH]         - GET or DELETE PATH
  mb [post|put] [PATH] -         - POST or PUT payload (STDIN) to PATH

  * A host must be configured for mb to operate
  * method, path, and payload, if configured, can be omitted as CLI arguments
  * accept is optional; valid values include json, html, text
USAGE
  puts
  puts "CONFIG: #{Mudbug.dump_config}" if Mudbug.fresh?

  exit 1
end

def conclude(msg)
  puts msg
  exit 0
end

require 'mudbug'

CFG_FILE = File.expand_path '~/.mudbug'
FILE_EXPIRY = 3600 # seconds

class Mudbug
  def self.save config
    raise "unable to write to #{CFG_FILE}" unless File.writable? CFG_FILE
    File.open(CFG_FILE, 'w') { |f| f.write config.to_json }
  end

  def self.load
    if self.fresh?
      File.open(CFG_FILE, 'r') { |f| JSON.parse(f.read) rescue nil }
    end
  end

  def self.fresh?
    File.exists?(CFG_FILE) and File.readable?(CFG_FILE) and
      Time.now - File.mtime(CFG_FILE) < FILE_EXPIRY
  end

  def self.dump_config
    JSON.pretty_generate load if fresh?
  end
end

CFG = Mudbug.load || {}

#
# Stage 1: handle commands that manipulate CFG / CFG_FILE
#

# don't consume ARGV here
cfg_cmd = ARGV.first

if cfg_cmd
  cfg_cmd = cfg_cmd.downcase

  case cfg_cmd
  when 'host', 'method', 'path'
    ARGV.shift # confirmed cfg_cmd, go ahead and shift
    val = ARGV.shift
    if val and !val.empty?
      if val.downcase == 'nil'
        CFG.delete cfg_cmd
        Mudbug.save CFG
        conclude "removed config for #{cfg_cmd}"
      else
        CFG[cfg_cmd] = val
        Mudbug.save CFG
      end
    else
      val = CFG[cfg_cmd] or conclude "no #{cfg_cmd} is set"
    end
    conclude "Using #{cfg_cmd}: #{val}"

  when 'payload'
    ARGV.shift # confirmed
    val = ARGV.shift
    if val and !val.empty?
      case val.downcase
      when '-'
        CFG['payload'] = JSON.parse $stdin.read
        Mudbug.save CFG
      when 'nil'
        CFG.delete 'payload'
        Mudbug.save CFG
        conclude "removed config for payload"
      end
    else
      CFG['payload'] or conclude "no payload is set"
    end
    conclude "Using payload:\n#{JSON.pretty_generate CFG['payload']}"

  when 'accept'
    ARGV.shift # confirmed cfg_cmd, go ahead and shift
    accepts = []
    until ARGV.empty?
      accepts << ARGV.shift
    end

    case accepts.length
    when 0
      if CFG['accept']
        conclude "Using accept: #{CFG['accept'].join(' ')}"
      else
        conclude "no accept is set"
      end
    when 1
      # did they provide a quoted or CSV list? or pseudo-symbols with colons?
      accepts = accepts.first.split(/[ ,:]+/).map { |s|
        s.empty? ? nil : s
      }.compact
    else
      accepts.map! { |s| s.gsub %r{[ ,:]+}, '' }
    end
    CFG['accept'] = accepts
    Mudbug.save CFG
    conclude "using accept: #{CFG['accept']}"

  when 'config'
    if Mudbug.fresh?
      conclude Mudbug.dump_config
    else
      puts "no config available"
    end
  end
end

#
# Done with manipulating CFG and CFG_FILE
#

#
# Stage 2: create Mudbug based on CFG and command line options
#

# set the host, always from CFG
conclude "no host is set" unless CFG['host']
mb = Mudbug.new CFG['host']

mb.accept CFG['accept'].map(&:to_sym) if CFG['accept']

# set the method, possibly from CLI args
meth_cmd = ARGV.first
case meth_cmd
when 'get', 'post', 'put', 'delete', 'del'
  ARGV.shift # confirmed meth_cmd, go ahead and shift
  method = meth_cmd
else
  method = CFG['method'] or usage "no method provided"
end

# set the path, possibly from CLI args
path_cmd = ARGV.first
case path_cmd
when %r{^\/} # starts with a slash
  ARGV.shift # confirmed path_cmd, go ahead and shift
  path = path_cmd
else
  path = CFG['path'] or usage "no path provided"
end

#
# no payload yet; run GET and DELETE
#

case method
when 'get'
  begin
    data = mb.get path
  rescue RuntimeError => e
    puts "#{e} - #{e.class}"
    exit 1
  end
  conclude JSON.pretty_generate data
when 'del', 'delete'
  begin
    data = mb.delete path
  rescue RuntimeError => e
    puts "#{e} - #{e.class}"
    exit 1
  end
  conclude JSON.pretty_generate data
when 'post', 'put', 'patch'
  # do nothing for now
else
  usage "Bad HTTP method #{method}"
end

# to get here, we must be doing POST, PUT, or PATCH
# we need a payload

payload = ARGV.first
case payload
when nil
  payload = CFG['payload'] or usage "no payload provided"
when '-'
  payload = $stdin.read
  begin
    JSON.parse payload
  rescue
    usage "could not parse payload:\n#{payload.inspect}"
  end
end

begin
  data = mb.send(method, path, payload)
rescue RuntimeError => e
  puts "#{e} - #{e.class}"
  exit 1
end

conclude JSON.pretty_generate data
