#!/usr/bin/env ruby

require 'dotcfg'
require 'mudbug'

CONFIG = DotCfg.new '~/.mudbug', :json

def usage(msg = nil)
  print "ERROR: #{msg}\n\n" if msg
  puts <<EOF
USAGE:
  mb [get|delete] [PATH]         - GET or DELETE PATH
  mb [post|put] [PATH] -         - POST or PUT payload (STDIN) to PATH

  mb host|method|path [VAL]      - Set or display current config item
  mb accept [ACC1] [ACC2] [etc]  - Set or display accept types
  mb payload [-]                 - Set (from STDIN) or display payload config
  mb config                      - Display current config

  * A `host` must be configured for mb to operate
  * `method`, `path`, and `payload`, if configured, are not required arguments
  * Set a config item to nil in order to remove it
  * `accept` is optional; valid values include json, html, text
EOF
  puts
  puts "CONFIG: #{CONFIG.pretty}"

  exit 1
end

def conclude(msg)
  puts msg
  exit 0
end

#
# Config section: handle commands that manipulate CONFIG
# Should exit in all cases with conclude()
#

# don't consume ARGV here
cfg_cmd = ARGV.first

if cfg_cmd
  cfg_cmd = cfg_cmd.downcase

  case cfg_cmd
  when 'host', 'method', 'path'
    ARGV.shift # confirmed cfg_cmd, go ahead and shift
    val = ARGV.shift
    if val and !val.empty?
      if val.downcase == 'nil'
        CONFIG.delete cfg_cmd
        CONFIG.save
        conclude "removed config for #{cfg_cmd}"
      else
        CONFIG[cfg_cmd] = val
        CONFIG.save
      end
    else
      val = CONFIG[cfg_cmd] or conclude "no #{cfg_cmd} is set"
    end
    conclude "Using #{cfg_cmd}: #{val}"

  when 'reset'
    CONFIG.reset
    conclude "config was reset"

  when 'payload'
    ARGV.shift # confirmed
    val = ARGV.shift
    if val and !val.empty?
      case val.downcase
      when '-'
        CONFIG['payload'] = JSON.parse $stdin.read
        CONFIG.save
      when 'nil'
        CONFIG.delete 'payload'
        CONFIG.save
        conclude "removed config for payload"
      end
    else
      CONFIG['payload'] or conclude "no payload is set"
    end
    conclude "Using payload:\n#{JSON.pretty_generate CONFIG['payload']}"

  when 'accept'
    ARGV.shift # confirmed cfg_cmd, go ahead and shift
    accepts = []
    until ARGV.empty?
      accepts << ARGV.shift
    end

    case accepts.length
    when 0
      if CONFIG['accept']
        conclude "Using accept: #{CONFIG['accept'].join(' ')}"
      else
        conclude "no accept is set"
      end
    when 1
      # did they provide a quoted or CSV list? or pseudo-symbols with colons?
      accepts = accepts.first.split(/[ ,:]+/).select { |s| !s.empty? }
    else
      accepts.map! { |s| s.gsub %r{[ ,:]+}, '' }
    end
    CONFIG['accept'] = accepts
    CONFIG.save
    conclude "using accept: #{CONFIG['accept']}"

  when 'config'
    conclude CONFIG.pretty
  end
end

#
# OK, we're not manipulating CONFIG
# Create Mudbug, determine method and path - from CONFIG and cmd line args
#

# set the host, always from CONFIG
#
usage "no host is set" unless CONFIG['host']
mb = Mudbug.new CONFIG['host']

mb.accept CONFIG['accept'].map(&:to_sym) if CONFIG['accept']

# set the method, possibly from CLI args
#
case ARGV.first
when 'get', 'post', 'put', 'delete'# , 'patch'   # Soon(tm)
  method = ARGV.shift
else
  method = CONFIG['method'] or usage "no method provided"
end

# set the path, possibly from CLI args
#
case ARGV.first
when %r{^\/} # starts with a slash
  path = ARGV.shift
else
  path = CONFIG['path'] or usage "no path provided"
end

# determine method
# gather payload as required
# create args for sending the request
#
case method
when 'get', 'delete'
  args = [method, path]
when 'post', 'put', 'patch'
  # get payload
  case ARGV.first
  when nil
    payload = CONFIG['payload'] or usage "no payload provided"
  when '-'
    begin
      payload = JSON.parse $stdin.read
    rescue
      usage "could not parse payload:\n#{payload.inspect}"
    end
  end
  args = [method, path, payload]
else
  usage "Bad HTTP method #{method}"
end

#
# finally!
#

begin
  data = mb.send(*args)
rescue RuntimeError => e
  puts "#{e} - #{e.class}"
  exit 1
end

data = JSON.pretty_generate data unless data.is_a? String
conclude data
