#!/usr/bin/env ruby

require 'mb_config'

def usage(msg = nil)
  puts "ERROR: #{msg}" if msg
  puts <<EOF
USAGE:
  mb [get|delete] [PATH]         - GET or DELETE PATH
  mb [post|put] [PATH] -         - POST or PUT payload (STDIN) to PATH

  mb host|method|path [VAL]      - Set or display current config item
  mb accept [ACC1] [ACC2] [etc]  - Set or display accept types
  mb payload [-]                 - Set (from STDIN) or display payload config
  mb config                      - Display current config

  * A host must be configured for mb to operate
  * method, path, and payload, if configured, can be omitted as CLI arguments
  * accept is optional; valid values include json, html, text
EOF
  puts
  puts "CONFIG: #{MbConfig.dump}"

  exit 1
end

def conclude(msg)
  puts msg
  exit 0
end

def display(maybe_json)
  return maybe_json if maybe_json.is_a?(String)
  JSON.pretty_generate maybe_json
end

#
# Config section: handle commands that manipulate MbConfig
# Should exit in all cases with conclude()
#

# don't consume ARGV here
cfg_cmd = ARGV.first

if cfg_cmd
  cfg_cmd = cfg_cmd.downcase

  case cfg_cmd
  when 'host', 'method', 'path'
    ARGV.shift # confirmed cfg_cmd, go ahead and shift
    val = ARGV.shift
    if val and !val.empty?
      if val.downcase == 'nil'
        MbConfig.delete cfg_cmd
        MbConfig.save
        conclude "removed config for #{cfg_cmd}"
      else
        MbConfig[cfg_cmd] = val
        MbConfig.save
      end
    else
      val = MbConfig[cfg_cmd] or conclude "no #{cfg_cmd} is set"
    end
    conclude "Using #{cfg_cmd}: #{val}"

  when 'reset'
    MbConfig.reset
    conclude "config was reset"

  when 'payload'
    ARGV.shift # confirmed
    val = ARGV.shift
    if val and !val.empty?
      case val.downcase
      when '-'
        MbConfig['payload'] = JSON.parse $stdin.read
        MbConfig.save
      when 'nil'
        MbConfig.delete 'payload'
        MbConfig.save
        conclude "removed config for payload"
      end
    else
      MbConfig['payload'] or conclude "no payload is set"
    end
    conclude "Using payload:\n#{JSON.pretty_generate MbConfig['payload']}"

  when 'accept'
    ARGV.shift # confirmed cfg_cmd, go ahead and shift
    accepts = []
    until ARGV.empty?
      accepts << ARGV.shift
    end

    case accepts.length
    when 0
      if MbConfig['accept']
        conclude "Using accept: #{MbConfig['accept'].join(' ')}"
      else
        conclude "no accept is set"
      end
    when 1
      # did they provide a quoted or CSV list? or pseudo-symbols with colons?
      accepts = accepts.first.split(/[ ,:]+/).map { |s|
        s.empty? ? nil : s
      }.compact
    else
      accepts.map! { |s| s.gsub %r{[ ,:]+}, '' }
    end
    MbConfig['accept'] = accepts
    MbConfig.save
    conclude "using accept: #{MbConfig['accept']}"

  when 'config'
    conclude MbConfig.dump
  end
end

#
# Done with manipulating MbConfig
# Create Mudbug, determine method and path - from MbConfig and cmd line args
#

# set the host, always from MbConfig
#
usage "no host is set" unless MbConfig['host']
mb = Mudbug.new MbConfig['host']

mb.accept MbConfig['accept'].map(&:to_sym) if MbConfig['accept']

# set the method, possibly from CLI args
#
meth_cmd = ARGV.first
case meth_cmd
when 'get', 'post', 'put', 'delete'# , 'patch'   # Soon(tm)
  ARGV.shift # confirmed meth_cmd, go ahead and shift
  method = meth_cmd
else
  method = MbConfig['method'] or usage "no method provided"
end

# set the path, possibly from CLI args
#
path_cmd = ARGV.first
case path_cmd
when %r{^\/} # starts with a slash
  ARGV.shift # confirmed path_cmd, go ahead and shift
  path = path_cmd
else
  path = MbConfig['path'] or usage "no path provided"
end

#
# Are we there yet?
#

# no payload yet; we can run GET and DELETE
#
case method
when 'get', 'delete'
  begin
    data = mb.send(method, path)
  rescue RuntimeError => e
    puts "#{e} - #{e.class}"
    exit 1
  end
  conclude display(data)
when 'post', 'put', 'patch'
  # do nothing for now
else
  usage "Bad HTTP method #{method}"
end

# to get here, we must be doing POST, PUT, or PATCH
# we need a payload.  from MbConfig or STDIN
#
payload = ARGV.first
case payload
when nil
  payload = MbConfig['payload'] or usage "no payload provided"
when '-'
  payload = $stdin.read
  begin
    JSON.parse payload
  rescue
    usage "could not parse payload:\n#{payload.inspect}"
  end
end

# run POST, PUT, PATCH
#
begin
  data = mb.send(method, path, payload)
rescue RuntimeError => e
  puts "#{e} - #{e.class}"
  exit 1
end

conclude display(data)
